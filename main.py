import logging
import os
import sqlite3
from enum import Enum
from functools import wraps
from typing import Optional, List

import aiosqlite
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.constants import ChatAction
from telegram.ext import Application, ContextTypes, ApplicationBuilder, \
    MessageHandler


logging.basicConfig(
    format='%(asctime)s - %(levelname)s - %(message)s',
    level=logging.INFO,
)
logger = logging.getLogger(__name__)

# Constants
DB_FILE = 'db/users.db'
TEXTS_DIR = 'texts'
PICTURES_DIR = 'pics'
API_TOKEN = os.getenv("TELEGRAM_API_TOKEN")  # Use an environment variable for the token


class UserState(Enum):
    START = "start"
    AFTER_START = "after_start"
    AFTER_NAME = "after_name"
    BLACK = 'black'
    CHOOSE_NAME = "choose_name"
    COMMON = "common"
    DICT = "dict"
    END = "end"
    FAULTS = "faults"
    FIRE = "fire"
    FIRST_DAY = "first_day"
    GRAY = "gray"
    HOW_TO_FIRE = "how_to_fire"
    MC1 = "mc1"
    MC2 = "mc2"
    MC3 = "mc3"
    MC_START = "mc_start"
    MENU = "menu"
    NIGHT = "night"
    RED = "red"
    TEST_END = "test_end"
    TEST_Q1 = "test_q1"
    TEST_Q2 = "test_q2"
    TEST_Q3 = "test_q3"
    VOTING = "voting"
    WHERE = "where"
    WHO = "who"
    YELLOW = "yellow"
    ZERO_NIGHT = "zero_night"


STAGES = [
    UserState.START,
    UserState.AFTER_START,
    UserState.CHOOSE_NAME,
    UserState.AFTER_NAME,
    UserState.COMMON,
    UserState.RED,
    UserState.YELLOW,
    UserState.BLACK,
    UserState.GRAY,
    UserState.HOW_TO_FIRE,
    UserState.FIRST_DAY,
    UserState.VOTING,
    UserState.FIRE,
    UserState.NIGHT,
    UserState.FAULTS,
    UserState.WHO,
    UserState.DICT,
    UserState.TEST_Q1,
    UserState.TEST_Q2,
    UserState.TEST_Q3,
    UserState.TEST_END,
    UserState.MC_START,
    UserState.MC1,
    UserState.MC2,
    UserState.MC3,
    UserState.WHERE,
    UserState.END,
    UserState.MENU
]

stages_names = {
    "–û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è": UserState.COMMON,
    "–ú–∏—Ä–Ω—ã–π –∂–∏—Ç–µ–ª—å": UserState.RED,
    "–®–µ—Ä–∏—Ñ": UserState.YELLOW,
    "–ú–∞—Ñ–∏—è": UserState.BLACK,
    "–î–æ–Ω": UserState.GRAY,
    "–î–æ–≥–æ–≤–æ—Ä–∫–∞ –º–∞—Ñ–∏–∏": UserState.HOW_TO_FIRE,
    "–î–µ–Ω—å": UserState.FIRST_DAY,
    "–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ": UserState.VOTING,
    "–°—Ç—Ä–µ–ª—å–±–∞": UserState.FIRE,
    "–ù–æ—á–Ω–∞—è —Ñ–∞–∑–∞": UserState.NIGHT,
    "–§–æ–ª—ã –∏ –∑–∞–ø—Ä–µ—â–µ–Ω–Ω—ã–µ —Ñ—Ä–∞–∑—ã": UserState.FAULTS,
    "–ñ–µ—Å—Ç –≤–æ–ø—Ä–æ—Å–∞": UserState.WHO,
    "–°–ª–æ–≤–∞—Ä—å": UserState.DICT,
    "–¢–µ—Å—Ç –∑–Ω–∞–Ω–∏–π": UserState.TEST_Q1,
    "–ü–æ–ª–µ–∑–Ω—ã–µ —Å—Å—ã–ª–∫–∏": UserState.MC1,
    "–ì–¥–µ –∏–≥—Ä–∞—Ç—å?": UserState.WHERE,
}


# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
def init_db() -> None:
    with sqlite3.connect(DB_FILE) as db:
        db.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT,
                state TEXT
            )
        ''')
        db.commit()


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
async def add_user(user_id: int, username: str) -> None:
    async with aiosqlite.connect(DB_FILE) as db:
        await db.execute('INSERT OR IGNORE INTO users (id, username, state) VALUES (?, ?, ?)',
                         (user_id, username, UserState.START.value))
        await db.commit()


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
async def update_user_state(user_id: int, state: UserState) -> None:
    async with aiosqlite.connect(DB_FILE) as db:
        await db.execute('UPDATE users SET state = ? WHERE id = ?', (state.value, user_id))
        await db.commit()


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
async def get_user_state(user_id: int) -> Optional[UserState]:
    async with aiosqlite.connect(DB_FILE) as db:
        async with db.execute('SELECT state FROM users WHERE id = ?', (user_id,)) as cursor:
            row = await cursor.fetchone()
            return UserState(row[0]) if row else None


# –ß—Ç–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–≤ –∏–∑ —Ñ–∞–π–ª–æ–≤
def load_text(filename: str) -> str:
    with open(os.path.join('texts', filename), 'r', encoding='utf-8') as file:
        return file.read()


def load_stage_text(stage: UserState, suffix: str = "") -> str:
    return load_text(stage.value + suffix + ".txt")


def send_action(action: ChatAction):
    """Sends `action` while processing func command."""

    def decorator(func):
        @wraps(func)
        async def command_func(update, context, *args, **kwargs):
            await context.bot.send_chat_action(chat_id=update.effective_message.chat_id, action=action)
            return await func(update, context, *args, **kwargs)

        return command_func

    return decorator


media_cache = {}


# –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–∞—Ä—Ç–∏–Ω–æ–∫ –∏–∑ –ø–∞–ø–∫–∏
async def send_image(update: Update, context: ContextTypes.DEFAULT_TYPE, image_path: str, text: Optional[str] = None,
                     reply_markup: Optional[ReplyKeyboardMarkup] = None) -> None:
    with open(os.path.join('pics', image_path), 'rb') as file:
        await context.bot.send_photo(chat_id=update.effective_chat.id,
                                     caption=text,
                                     photo=file,
                                     reply_markup=reply_markup)


async def send_video(update: Update, context: ContextTypes.DEFAULT_TYPE, video_path: str, text: Optional[str] = None,
                     reply_markup: Optional[ReplyKeyboardMarkup] = None) -> None:
    if video_path in media_cache:
        await context.bot.send_video(chat_id=update.effective_chat.id,
                                     caption=text,
                                     video=media_cache[video_path],
                                     reply_markup=reply_markup)
    else:
        with open(os.path.join('pics', video_path), 'rb') as file:
            update = await context.bot.send_video(chat_id=update.effective_chat.id,
                                                  caption=text,
                                                  video=file,
                                                  reply_markup=reply_markup)
            media_cache[video_path] = update.video.file_id


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –∫–Ω–æ–ø–∫–∏
@send_action(ChatAction.TYPING)
async def message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.message.from_user
    chat_id = update.message.chat.id
    state = await get_user_state(user.id)
    text = update.message.text
    logger.info(f"Message from {user} on state {state} with text {text}")

    if update.message.text == "/start" or state is None:
        state = UserState.START
        await add_user(user.id, user.username)
        await context.bot.send_message(chat_id=chat_id,
                                       text=load_stage_text(state),
                                       reply_markup=keyboard_from_messages(["–î–∞"]))
        await send_image(update, context, "start.jpg")
    elif state == UserState.MENU:
        # Handle menu selection
        new_state = stages_names[text]
        if new_state in UserState and new_state != UserState.MENU:
            await update_user_state(user.id, new_state)
            await message(update, context)
        else:
            await context.bot.send_message(chat_id=chat_id,
                                           text="Invalid selection. Please choose a valid stage.",
                                           reply_markup=keyboard_from_messages(
                                               [k for (k, v) in stages_names.items()]))
        return
    else:
        match state:
            case UserState.AFTER_START:
                await common_stage_process(chat_id, context, state, "–î–∞!")
            case UserState.CHOOSE_NAME:
                await context.bot.send_message(chat_id=chat_id,
                                               text=load_stage_text(state),
                                               reply_markup=None)
                await context.bot.send_message(chat_id=chat_id,
                                               text=load_stage_text(state, "2"),
                                               reply_markup=ReplyKeyboardRemove()
                                               )
            case UserState.AFTER_NAME:
                await common_stage_process(chat_id, context, state, "–ì–æ—Ç–æ–≤")
            case UserState.COMMON:
                await common_stage_process(chat_id, context, state, "–¢–µ–ø–µ—Ä—å —Ö–æ—á—É —É–∑–Ω–∞—Ç—å –ø—Ä–æ —Ä–æ–ª–∏!")
            case UserState.RED:
                await role_stage_process(chat_id, context, state, update, "–¢–∞–∫, –∞ —à–µ—Ä–∏—Ñ —Ç–æ–∂–µ –º–∏—Ä–Ω—ã–π –∂–∏—Ç–µ–ª—å? üïµÔ∏è")
            case UserState.YELLOW:
                await role_stage_process(chat_id, context, state, update, "–ê —Ç–µ–ø–µ—Ä—å –ø—Ä–æ –º–∞—Ñ–∏—é üòà")
            case UserState.BLACK:
                await role_stage_process(chat_id, context, state, update, "–ê –∫—Ç–æ —Ç–∞–∫–æ–π –¥–æ–Ω –º–∞—Ñ–∏–∏? üëÄ")
            case UserState.GRAY:
                await role_stage_process(chat_id, context, state, update, "–¢–∞–∫-—Ç–∞–∫-—Ç–∞–∫, –∞ –∫–∞–∫ –ø–æ–Ω—è—Ç—å –∫—É–¥–∞ —Å—Ç—Ä–µ–ª—è—Ç—å?üòÖ")
            case UserState.HOW_TO_FIRE:
                await common_stage_process(chat_id, context, state, "–í—Ä–æ–¥–µ –ø–æ–Ω—è—Ç–Ω–æ. –ß—Ç–æ –¥–∞–ª—å—à–µ? ‚òÄÔ∏è")
            case UserState.FIRST_DAY:
                await common_stage_process(chat_id, context, state, "–¢–∞–∫-—Ç–∞–∫, –∞ –∫–∞–∫ –≥–æ–ª–æ—Å–æ–≤–∞—Ç—å? ü§î")
            case UserState.VOTING:
                await context.bot.send_message(chat_id=chat_id,
                                               text=load_stage_text(state, "1"),
                                               reply_markup=None)
                await send_video(update, context,
                                 video_path="voting.mp4",
                                 text=load_stage_text(state, "2"),
                                 reply_markup=keyboard_from_messages(["–ê –ø–æ—Ç–æ–º —á—Ç–æ? ü§ì"])
                                 )
            case UserState.FIRE:
                await common_stage_process(chat_id, context, state, "–ê –¥–æ–Ω –º–∞—Ñ–∏–∏ –∏ —à–µ—Ä–∏—Ñ? üïµÔ∏è")
            case UserState.NIGHT:
                await context.bot.send_message(chat_id=chat_id,
                                               text=load_stage_text(state, "1"),
                                               reply_markup=None)
                await send_video(update, context,
                                 video_path="night.mp4",
                                 text=load_stage_text(state, "2"),
                                 reply_markup=keyboard_from_messages(["–≠—Ç–æ –≤—Å–µ? –£–∂–µ –º–æ–∂–Ω–æ –∏–≥—Ä–∞—Ç—å?üòù"])
                                 )
            case UserState.FAULTS:
                await common_stage_process(chat_id, context, state, "–¢–æ –µ—Å—Ç—å, –Ω–µ –≤ —Å–≤–æ—é –º–∏–Ω—É—Ç—É –Ω–µ–ª—å–∑—è –æ–±—â–∞—Ç—å—Å—è? üòßÔ∏è")
            case UserState.WHO:
                await context.bot.send_message(chat_id=chat_id,
                                               text=load_stage_text(state))
                await send_image(update, context, "who.jpg", load_stage_text(state, "2"),
                                 keyboard_from_messages(["–ê –µ—Å—Ç—å –µ—â–µ —á—Ç–æ-—Ç–æ –≤–∞–∂–Ω–æ–µ, —á—Ç–æ–±—ã —Å–µ–π—á–∞—Å —É–∑–Ω–∞—Ç—å?"]))
            case UserState.DICT:
                await common_stage_process(chat_id, context, state, "Ô∏è–¢–µ–ø–µ—Ä—å –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–Ω–∞–Ω–∏–π!")
            case UserState.TEST_Q1:
                await context.bot.send_message(chat_id=chat_id,
                                               text=load_stage_text(state),
                                               reply_markup=keyboard_from_messages(
                                                   ["–î–æ–Ω –º–∞—Ñ–∏–∏", "–ú–∞–Ω—å—è–∫", "–ú–∞—Ñ–∏—è", "–®–µ—Ä–∏—Ñ", "–ú–∏—Ä–Ω—ã–π –∂–∏—Ç–µ–ª—å"]))
            case UserState.TEST_Q2:
                if update.message.text != "–ú–∞–Ω—å—è–∫":
                    await context.bot.send_message(chat_id=chat_id,
                                                   text=load_text("test_a1.txt"))
                await context.bot.send_message(chat_id=chat_id,
                                               text=load_stage_text(state),
                                               reply_markup=keyboard_from_messages(["–ò–≥—Ä–æ–∫ ‚Ññ 5 - –º–∞—Ñ–∏—è",
                                                                                    "–ò–≥—Ä–æ–∫ ‚Ññ 5 - –º–∏—Ä–Ω—ã–π –∂–∏—Ç–µ–ª—å",
                                                                                    "–í—ã –º–∞—Ñ–∏—è",
                                                                                    "–ò–≥—Ä–æ–∫ ‚Ññ 1 - —à–µ—Ä–∏—Ñ"]))
            case UserState.TEST_Q3:
                if update.message.text != "–ò–≥—Ä–æ–∫ ‚Ññ 5 - –º–∏—Ä–Ω—ã–π –∂–∏—Ç–µ–ª—å":
                    await context.bot.send_message(chat_id=chat_id,
                                                   text=load_text("test_a2.txt"))
                await context.bot.send_message(chat_id=chat_id,
                                               text=load_stage_text(state),
                                               reply_markup=keyboard_from_messages(
                                                   ["–°—Ç—Ä–µ–ª—è–µ–º –≤ –ø–µ—Ä–≤—É—é –Ω–æ—á—å –∏ –≤ 1, –∏ –≤ 6, –∏ –≤ 4",
                                                    "–ü–µ—Ä–≤–æ–π –Ω–æ—á—å—é —Å—Ç—Ä–µ–ª—è–µ–º –≤ –∏–≥—Ä–æ–∫–∞ 1, —Å–ª–µ–¥—É—é—â–µ–π –≤ 6, –ø–æ—Ç–æ–º –≤ 4.",
                                                    "–ù—É–∂–Ω–æ –ø—Ä–æ—Å–Ω—É—Ç—å—Å—è –Ω–æ—á—å—é: –∫–æ–≥–¥–∞ –Ω–∞–∑–æ–≤—É—Ç 1", ]))
            case UserState.TEST_END:
                if update.message.text != "–ü–µ—Ä–≤–æ–π –Ω–æ—á—å—é —Å—Ç—Ä–µ–ª—è–µ–º –≤ –∏–≥—Ä–æ–∫–∞ 1, —Å–ª–µ–¥—É—é—â–µ–π –≤ 6, –ø–æ—Ç–æ–º –≤ 4.":
                    await context.bot.send_message(chat_id=chat_id,
                                                   text=load_text("test_a3.txt"))
                await common_stage_process(chat_id, context, state, "–Ø —É–∂–µ –ø–æ–∏–≥—Ä–∞–ª! üòé")
            case UserState.MC_START:
                await common_stage_process(chat_id, context, state, "–î–∞ üòÅ")
            case UserState.MC1:
                await common_stage_process(chat_id, context, state, "–¢–∞–∫, –∞ —á—Ç–æ –µ—â–µ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å? ü§î")
            case UserState.MC2:
                await common_stage_process(chat_id, context, state, "–°—É–ø–µ—Ä! üòç")
            case UserState.MC3:
                await common_stage_process(chat_id, context, state, "–ê –≥–¥–µ –º–æ–∂–Ω–æ –ø–æ–∏–≥—Ä–∞—Ç—å? üòá")
            case UserState.WHERE:
                await common_stage_process(chat_id, context, state, "üòãüòãüòã")
            case UserState.END:
                await context.bot.send_message(chat_id=chat_id,
                                               text=load_stage_text(state),
                                               reply_markup=keyboard_from_messages(
                                                   [k for (k, v) in stages_names.items()]))
                await update_user_state(user.id, UserState.MENU)
                return

    next_stage = STAGES[(STAGES.index(state) + 1) % len(STAGES)]
    await update_user_state(user.id, next_stage)


async def common_stage_process(chat_id, context, state, reply_str=None):
    await context.bot.send_message(chat_id=chat_id,
                                   text=load_stage_text(state),
                                   reply_markup=keyboard_from_messages([reply_str] if reply_str else ["–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é"]))
    if reply_str is None:
        await update_user_state(chat_id, UserState.MENU)

async def role_stage_process(chat_id, context, state, update, reply_str):
    await context.bot.send_message(chat_id=chat_id,
                                   text=load_stage_text(state, "1"),
                                   reply_markup=None)
    await send_image(update, context, state.value + ".jpg", load_stage_text(state, "2"),
                     keyboard_from_messages([reply_str]))


def keyboard_from_messages(messages: List[str]) -> ReplyKeyboardMarkup:
    keyboard = list(map(lambda it: [it], messages))
    return ReplyKeyboardMarkup(keyboard)


# –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
def main() -> Application:
    init_db()

    app = ApplicationBuilder().token(API_TOKEN).build()

    app.add_handler(MessageHandler(None, message))

    return app


if __name__ == '__main__':
    main().run_polling()
